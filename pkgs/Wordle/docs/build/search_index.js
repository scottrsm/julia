var documenterSearchIndex = {"docs":
[{"location":"#Wordle.jl-Documentation","page":"Wordle.jl Documentation","title":"Wordle.jl Documentation","text":"","category":"section"},{"location":"","page":"Wordle.jl Documentation","title":"Wordle.jl Documentation","text":"CurrentModule = Wordle","category":"page"},{"location":"#Functions","page":"Wordle.jl Documentation","title":"Functions","text":"","category":"section"},{"location":"","page":"Wordle.jl Documentation","title":"Wordle.jl Documentation","text":"create_wordle_info","category":"page"},{"location":"#Wordle.create_wordle_info","page":"Wordle.jl Documentation","title":"Wordle.create_wordle_info","text":"create_wordle_info(guess, pword)\n\nCreate an information structure of the form: \n\n([LETTER, EXACT_MATCH_POSITION)], Dict(LETTER => (NUMBER_OF_MATCHES, MATCH_FLAG))\n\nHere, the dictionary has the in-exact match information:     LETTER : A matching letter      NUMBER_OF_MATCHES : The number of matches.     The latter is interpreted thusly: \n\nIf MATCH_FLAG is 0, there are exactly NUMBER_OF_MATCHES                    with this letter that should occur in the puzzle word.\nElse           there are at least NUMBER_OF_MATCHES                    with this letter that should occur in the puzzle word.\n\nArguments\n\nguess::String: The guess for the puzzle.\npword::String: The puzzle word.\n\nReturns\n\nA tuple of a vector of tuples of exact matches and a dictionary of \nnon-exact match info.\n\nExamples\n\njulia> create_wordle_info(\"which\", \"where\")\n([('w', 1), ('h', 2)], Dict('h' => (0, 0), 'c' => (0, 0), 'i' => (0, 0)))\n\njulia> create_wordle_info(\"teens\", \"where\")\n([('e', 3)], Dict('n' => (0, 0), 's' => (0, 0), 't' => (0, 0), 'e' => (1, 1)))\n\n\n\n\n\n","category":"function"},{"location":"","page":"Wordle.jl Documentation","title":"Wordle.jl Documentation","text":"filter_universe","category":"page"},{"location":"#Wordle.filter_universe","page":"Wordle.jl Documentation","title":"Wordle.filter_universe","text":"filter_universe(wordle_info, words)\n\nFilter an existing universe of words based on match info.\n\nArguments\n\nwordle_info : Wordle info of the form:                    ([(LETTER, EXACT_POSITION)], Dict( LETTER => (k, n)))                 The Wordle info – the same type as the return value form                  create_wordle_info.\nwords       : A Vector of words.\n\nReturn\n\nA subset of the words vector based on the filter information     from wordle_info.\n\nExamples\n\njulia> (winfo, d) = create_wordle_info(\"which\", \"where\")\n\n([('w', 1), ('h', 2)], Dict('h' => (0, 0), 'c' => (0, 0), 'i' => (0, 0)))\n\njulia> words = [\"state\", \"which\", \"where\", \"child\", \"there\", \"taste\"]\n\njulia> filter_universe((winfo, d), words)\n\n1-element Vector{String}:\n \"where\"\n\n\n\n\n\n","category":"function"},{"location":"","page":"Wordle.jl Documentation","title":"Wordle.jl Documentation","text":"solve_wordle","category":"page"},{"location":"#Wordle.solve_wordle","page":"Wordle.jl Documentation","title":"Wordle.solve_wordle","text":"solve_wordle(puzzle_word, universe_df, rec_count, sol_path, last_guess, \n                lfa[; chk_inputs, guess_strategy])\n\nSolves a Wordle puzzle.\n\nBy default, makes guesses based on the most frequently used  word in the universe passed in. However, there is an option to pass in a guessing strategy function.\n\nASSUMES: The universe DataFrame is sorted from highest frequency to lowest.\n\nArguments\n\npuzzle_word : The puzzle word.\nuniverse_df : A DataFrame with schema: word(words of the same length),                    freq(freq fraction by use)\nNOTE: The universe is assumed to be sorted in               reverse order by the :freq column.\nrec_count   : The number of calls to this function.\nsol_path    : Any containing the current list of guesses:                    [ (guess, exact_info, universe_size) ...]\nlast_guess  : The previous guess.\nlfa         : The lowercase alphabet listed in frequency of use order.\n\nKeyword Arguments\n\nchk_inputs     : If true, check the input contract.\nguess_strategy : If not nothing, apply this function to pick the next guess.                    If nothing, pick the next guess as the most frequent word                    in the current universe.\nul             : The lower threshold size of the filtered Wordle universe.\nuu             : The upper threshold size of the filtered Wordle universe.\ninit_guess     : The starting guess to use.\n\nHere, \n\nexact_info has the form: [(LETTER, POSITION) ...]\nuniverse_size is the size the word list when the guess was made.\nThe guess_strategy is only turned on when the filtered Wordle universe is between the thresholds: ul and uu; otherwise, the default strategy is used – the most frequently used word in the existing filtered Wordle universe is chosen.\n\nReturn\n\n(sol_path, number-of-guesses, :SUCCESS/:FAILURE)\n\nNOTE: A sol_path that does not include the puzzle word, means               that at some point after a guess was made – along with               the corresponding filtering of the universe – there was                only one word left. In this case the guess count was                increased by 1, but the function did not recurse.\n\nExamples\n\njulia> solve_wordle(\"taste\")\n\n(Any[(\"their\", [('t', 1)], 3027), \n     (\"taken\", [('t', 1), ('a', 2)], 31), \n     (\"table\", [('t', 1), ('a', 2), ('e', 5)], 5), \n     (\"taste\", [('t', 1), ('a', 2), ('s', 3), ('t', 4), ('e', 5)], 2)], 4, :SUCCESS)\n\nInput Contract\n\nuniverse_df schema is (:word, :freq)\nIf words is an N-vector of the words from universe_df, then\n∃ m > 0, ∀ i∈[1,N], |words[i]| = m  (All the words in universe_df have the same length.)\nwords = words[argsort[universe_df[:freq]]] (Words are sorted from highest to lowest word usage.)\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"Wordle.jl Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"Wordle.jl Documentation","title":"Wordle.jl Documentation","text":"","category":"page"}]
}
